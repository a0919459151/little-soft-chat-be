# èŠå¤©å®¤å¾Œç«¯æ¶æ§‹è¨­è¨ˆæ–‡ä»¶
**ç‰ˆæœ¬**: 1.0  
**æ—¥æœŸ**: 2025-06-08  
**æŠ€è¡“æ£§**: .NET 8 + gRPC + SignalR + MySQL 8

## ğŸ“‹ ç›®éŒ„
- [1. æ¶æ§‹æ¦‚è¦½](#1-æ¶æ§‹æ¦‚è¦½)
- [2. å¾®æœå‹™è¨­è¨ˆ](#2-å¾®æœå‹™è¨­è¨ˆ)
- [3. å…±äº«å…§æ ¸ (Shared Kernel)](#3-å…±äº«å…§æ ¸-shared-kernel)
- [4. CQRS æ¨¡å¼è¨­è¨ˆ](#4-cqrs-æ¨¡å¼è¨­è¨ˆ)
- [5. è³‡æ–™åº«è¨­è¨ˆ](#5-è³‡æ–™åº«è¨­è¨ˆ)
- [6. gRPC æœå‹™å¥‘ç´„](#6-grpc-æœå‹™å¥‘ç´„)
- [7. ACL é˜²è…å±¤](#7-acl-é˜²è…å±¤)
- [8. JWT èªè­‰æ¶æ§‹](#8-jwt-èªè­‰æ¶æ§‹)
- [9. SignalR å³æ™‚é€šè¨Š](#9-signalr-å³æ™‚é€šè¨Š)
- [10. Docker éƒ¨ç½²](#10-docker-éƒ¨ç½²)
- [11. é–‹ç™¼è¦ç¯„](#11-é–‹ç™¼è¦ç¯„)

## 1. æ¶æ§‹æ¦‚è¦½

### 1.1 å°ˆæ¡ˆçµæ§‹
```
chat-room-backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ ApiGateway/                       # API é–˜é“
â”‚   â”‚   â””â”€â”€ ChatRoom.Gateway/
â”‚   â”œâ”€â”€ Services/                         # å¾®æœå‹™
â”‚   â”‚   â”œâ”€â”€ User/                         # ç”¨æˆ¶æœå‹™
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.User.API/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.User.Application/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.User.Domain/
â”‚   â”‚   â”‚   â””â”€â”€ ChatRoom.User.Infrastructure/
â”‚   â”‚   â”œâ”€â”€ Chat/                         # èŠå¤©æœå‹™
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.Chat.API/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.Chat.Application/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoom.Chat.Domain/
â”‚   â”‚   â”‚   â””â”€â”€ ChatRoom.Chat.Infrastructure/
â”‚   â”‚   â””â”€â”€ Notification/                 # é€šçŸ¥æœå‹™
â”‚   â”‚       â”œâ”€â”€ ChatRoom.Notification.API/
â”‚   â”‚       â”œâ”€â”€ ChatRoom.Notification.Application/
â”‚   â”‚       â”œâ”€â”€ ChatRoom.Notification.Domain/
â”‚   â”‚       â””â”€â”€ ChatRoom.Notification.Infrastructure/
â”‚   â””â”€â”€ Shared/                           # å…±äº«å…§æ ¸
â”‚       â”œâ”€â”€ ChatRoom.Shared.Contracts/    # gRPC å¥‘ç´„
â”‚       â”œâ”€â”€ ChatRoom.Shared.Domain/       # å…±ç”¨é ˜åŸŸæ¨¡å‹
â”‚       â””â”€â”€ ChatRoom.Shared.Infrastructure/ # å…±ç”¨åŸºç¤è¨­æ–½
â”œâ”€â”€ database/                             # è³‡æ–™åº«è…³æœ¬
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

### 1.2 æœå‹™è·è²¬åŠƒåˆ†

| æœå‹™ | ç«¯å£ | è·è²¬ | æŠ€è¡“ç‰¹é» |
|------|------|------|----------|
| **User Service** | 5001/5101 | ç”¨æˆ¶èªè­‰ã€å€‹äººè³‡æ–™ç®¡ç† | JWT èªè­‰ã€gRPC |
| **Chat Service** | 5002/5102 | å¥½å‹ç®¡ç†ã€ç§äººè¨Šæ¯ã€æ©Ÿå™¨äºº | CQRSã€gRPC |
| **Notification Service** | 5003/5103 | å³æ™‚é€šè¨Šã€æ¨é€é€šçŸ¥ | SignalRã€gRPC |
| **API Gateway** | 5000 | è·¯ç”±ã€è² è¼‰å¹³è¡¡ | HTTP è½‰ç™¼ |

## 2. å¾®æœå‹™è¨­è¨ˆ

### 2.1 ç”¨æˆ¶æœå‹™ (User Service)

**æ ¸å¿ƒè·è²¬:**
- JWT Token ç”Ÿæˆèˆ‡é©—è­‰
- ç”¨æˆ¶å€‹äººè³‡æ–™ CRUD
- ç”¨æˆ¶æœå°‹åŠŸèƒ½

**API è¨­è¨ˆ:**
```csharp
// HTTP API
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        var command = new LoginCommand(request.Username, request.Password);
        var result = await _mediator.Send(command);
        return Ok(result);
    }
    
    [HttpGet("profile")]
    [Authorize]
    public async Task<IActionResult> GetProfile()
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetUserProfileQuery(userId);
        var result = await _mediator.Send(query);
        return Ok(result);
    }
    
    [HttpPut("profile")]
    [Authorize]
    public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new UpdateUserProfileCommand(userId, request.DisplayName, request.Avatar);
        var result = await _mediator.Send(command);
        return Ok(result);
    }
}

// gRPC Service
public class UserGrpcService : UserService.UserServiceBase
{
    private readonly IMediator _mediator;

    public override async Task<GetUserResponse> GetUser(GetUserRequest request, ServerCallContext context)
    {
        var query = new GetUserByIdQuery(request.UserId);
        var user = await _mediator.Send(query);
        
        return new GetUserResponse
        {
            Id = user.Id,
            Username = user.Username,
            DisplayName = user.DisplayName,
            Avatar = user.Avatar,
            IsActive = user.IsActive
        };
    }

    public override async Task<GetUsersResponse> GetUsers(GetUsersRequest request, ServerCallContext context)
    {
        var query = new GetUsersByIdsQuery(request.UserIds.ToList());
        var users = await _mediator.Send(query);
        
        var response = new GetUsersResponse();
        response.Users.AddRange(users.Select(u => new UserResponse
        {
            Id = u.Id,
            Username = u.Username,
            DisplayName = u.DisplayName,
            Avatar = u.Avatar,
            IsActive = u.IsActive
        }));
        
        return response;
    }
}
```

### 2.2 èŠå¤©æœå‹™ (Chat Service)

**æ ¸å¿ƒè·è²¬:**
- å¥½å‹é—œä¿‚ç®¡ç† (é‚€è«‹ã€æ¥å—ã€æ‹’çµ•)
- ç§äººè¨Šæ¯è™•ç†
- æ©Ÿå™¨äººå›è¦†é‚è¼¯

**CQRS è¨­è¨ˆ:**
```csharp
// Commands (å¯«æ“ä½œ) - ç›´æ¥ä½¿ç”¨ MediatR IRequest
public record SendMessageCommand(int SenderId, int ReceiverId, string Content) : IRequest<SendMessageResult>;

public record SendFriendRequestCommand(int RequesterId, int ReceiverId) : IRequest<FriendRequestResult>;

public record AcceptFriendRequestCommand(int FriendshipId, int UserId) : IRequest<FriendRequestResult>;

// Queries (è®€æ“ä½œ) - ç›´æ¥ä½¿ç”¨ MediatR IRequest  
public record GetMessagesQuery(int UserId, int FriendId, int Page, int Size) : IRequest<PagedResult<MessageDto>>;

public record GetFriendsQuery(int UserId) : IRequest<List<FriendDto>>;

public record GetFriendRequestsQuery(int UserId) : IRequest<List<FriendRequestDto>>;

// Command Handlers - ç›´æ¥å¯¦ä½œ MediatR IRequestHandler
public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    private readonly IMessageRepository _messageRepository;
    private readonly IUserGrpcClient _userGrpcClient;
    private readonly INotificationHttpClient _notificationHttpClient;
    private readonly ILogger<SendMessageCommandHandler> _logger;

    public SendMessageCommandHandler(
        IMessageRepository messageRepository,
        IUserGrpcClient userGrpcClient,
        INotificationHttpClient notificationHttpClient,
        ILogger<SendMessageCommandHandler> logger)
    {
        _messageRepository = messageRepository;
        _userGrpcClient = userGrpcClient;
        _notificationHttpClient = notificationHttpClient;
        _logger = logger;
    }

    public async Task<SendMessageResult> Handle(SendMessageCommand request, CancellationToken cancellationToken)
    {
        // 1. é©—è­‰ç”¨æˆ¶ (é€šé gRPC)
        var sender = await _userGrpcClient.GetUserAsync(request.SenderId);
        var receiver = await _userGrpcClient.GetUserAsync(request.ReceiverId);

        if (sender == null || receiver == null || !sender.IsActive || !receiver.IsActive)
        {
            return SendMessageResult.Failure("Invalid users");
        }

        // 2. ä¿å­˜è¨Šæ¯
        var message = new Message
        {
            SenderId = request.SenderId,
            ReceiverId = request.ReceiverId,
            Content = request.Content,
            MessageType = "text",
            CreatedAt = DateTime.UtcNow
        };

        var messageId = await _messageRepository.CreateAsync(message);

        // 3. æ©Ÿå™¨äººå›è¦† (ç¬¬ä¸€éšæ®µï¼šé‡è¤‡å…§å®¹)
        var botReply = new Message
        {
            SenderId = 0, // Bot ID
            ReceiverId = request.SenderId,
            Content = $"Bot: {request.Content}",
            MessageType = "bot_reply",
            CreatedAt = DateTime.UtcNow
        };

        await _messageRepository.CreateAsync(botReply);

        // 4. ç™¼é€é€šçŸ¥ (éåŒæ­¥ï¼Œä¸å½±éŸ¿ä¸»æµç¨‹)
        _ = Task.Run(async () =>
        {
            try
            {
                await _notificationHttpClient.SendNotificationAsync(
                    request.ReceiverId,
                    $"ä¾†è‡ª {sender.DisplayName} çš„æ–°è¨Šæ¯",
                    "new_message"
                );
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to send notification for message {MessageId}", messageId);
            }
        }, cancellationToken);

        return SendMessageResult.Success(messageId);
    }
}

// Query Handlers - ç›´æ¥å¯¦ä½œ MediatR IRequestHandler
public class GetMessagesQueryHandler : IRequestHandler<GetMessagesQuery, PagedResult<MessageDto>>
{
    private readonly IDbConnectionFactory _dbFactory;

    public GetMessagesQueryHandler(IDbConnectionFactory dbFactory)
    {
        _dbFactory = dbFactory;
    }

    public async Task<PagedResult<MessageDto>> Handle(GetMessagesQuery request, CancellationToken cancellationToken)
    {
        using var connection = _dbFactory.CreateConnection();
        
        var sql = @"
            SELECT Id, SenderId, ReceiverId, Content, MessageType, IsRead, CreatedAt
            FROM Messages 
            WHERE (SenderId = @UserId AND ReceiverId = @FriendId) 
               OR (SenderId = @FriendId AND ReceiverId = @UserId)
            ORDER BY CreatedAt DESC
            LIMIT @Offset, @Size";

        var messages = await connection.QueryAsync<MessageDto>(sql, new
        {
            UserId = request.UserId,
            FriendId = request.FriendId,
            Offset = (request.Page - 1) * request.Size,
            Size = request.Size
        });

        var totalSql = @"
            SELECT COUNT(*)
            FROM Messages 
            WHERE (SenderId = @UserId AND ReceiverId = @FriendId) 
               OR (SenderId = @FriendId AND ReceiverId = @UserId)";

        var total = await connection.QuerySingleAsync<int>(totalSql, new
        {
            UserId = request.UserId,
            FriendId = request.FriendId
        });

        return new PagedResult<MessageDto>(messages.ToList(), request.Page, request.Size, total);
    }
}
```

### 2.3 é€šçŸ¥æœå‹™ (Notification Service)

**æ ¸å¿ƒè·è²¬:**
- SignalR Hub ç®¡ç†
- ç”¨æˆ¶é€£ç·šç‹€æ…‹è¿½è¹¤
- å³æ™‚æ¨é€é€šçŸ¥

**MediatR æ•´åˆ:**
```csharp
// Commands
public record SendNotificationCommand(int UserId, string Message, string Type) : IRequest<bool>;

public record UpdateUserConnectionCommand(int UserId, string ConnectionId, bool IsOnline) : IRequest;

// Command Handlers
public class SendNotificationCommandHandler : IRequestHandler<SendNotificationCommand, bool>
{
    private readonly IHubContext<ChatHub> _hubContext;
    private readonly IUserConnectionRepository _connectionRepository;

    public async Task<bool> Handle(SendNotificationCommand request, CancellationToken cancellationToken)
    {
        var connections = await _connectionRepository.GetUserConnectionsAsync(request.UserId);
        
        if (connections.Any())
        {
            await _hubContext.Clients.Clients(connections)
                .SendAsync("ReceiveNotification", new
                {
                    Message = request.Message,
                    Type = request.Type,
                    Timestamp = DateTime.UtcNow
                }, cancellationToken);
            return true;
        }
        
        return false;
    }
}

// SignalR Hub
[Authorize]
public class ChatHub : Hub
{
    private readonly IMediator _mediator;
    private readonly ILogger<ChatHub> _logger;

    public ChatHub(IMediator mediator, ILogger<ChatHub> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    public async Task JoinUserGroup()
    {
        var userId = int.Parse(Context.UserIdentifier!);
        await Groups.AddToGroupAsync(Context.ConnectionId, $"user_{userId}");
        
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, true);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} joined with connection {ConnectionId}", userId, Context.ConnectionId);
    }

    public async Task SendMessage(int receiverId, string message)
    {
        var senderId = int.Parse(Context.UserIdentifier!);
        
        var command = new SendMessageCommand(senderId, receiverId, message);
        var result = await _mediator.Send(command);

        if (result.IsSuccess)
        {
            await Clients.Group($"user_{receiverId}")
                .SendAsync("ReceiveMessage", new
                {
                    MessageId = result.MessageId,
                    SenderId = senderId,
                    Content = message,
                    MessageType = "text",
                    Timestamp = DateTime.UtcNow
                });

            await Clients.Caller.SendAsync("MessageSent", new { MessageId = result.MessageId });
        }
        else
        {
            await Clients.Caller.SendAsync("MessageError", result.ErrorMessage);
        }
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, false);
        await _mediator.Send(command);
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

## 3. å…±äº«å…§æ ¸ (Shared Kernel)

### 3.1 çµæ§‹è¨­è¨ˆ
```
ChatRoom.Shared.Infrastructure/
â”œâ”€â”€ GrpcClients/                  # gRPC å®¢æˆ¶ç«¯ (ACL)
â”œâ”€â”€ HttpClients/                  # HTTP å®¢æˆ¶ç«¯ (ACL)
â”œâ”€â”€ Authentication/               # JWT èªè­‰æ¨¡çµ„
â”œâ”€â”€ Database/                     # è³‡æ–™åº«é€šç”¨åŠŸèƒ½
â”œâ”€â”€ Logging/                      # æ—¥èªŒæ¨¡çµ„
â”œâ”€â”€ HealthChecks/                 # å¥åº·æª¢æŸ¥
â”œâ”€â”€ Extensions/                   # æ“´å±•æ–¹æ³•
â””â”€â”€ DependencyInjection.cs       # çµ±ä¸€è¨»å†Š
```

### 3.2 MediatR é…ç½®
```csharp
// ChatRoom.Shared.Infrastructure/Extensions/MediatRExtensions.cs
public static class MediatRExtensions
{
    public static IServiceCollection AddMediatRWithBehaviors(this IServiceCollection services, Assembly assembly)
    {
        // è¨»å†Š MediatR
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(assembly));
        
        // è¨»å†Š Pipeline Behaviors
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(PerformanceBehavior<,>));
        
        return services;
    }
}

// æ—¥èªŒè¡Œç‚º
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;

    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        _logger.LogInformation("Handling {RequestName} with {@Request}", requestName, request);

        try
        {
            var response = await next();
            _logger.LogInformation("Completed {RequestName}", requestName);
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling {RequestName}", requestName);
            throw;
        }
    }
}

// é©—è­‰è¡Œç‚º
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        // åŸºæœ¬é©—è­‰é‚è¼¯ (ä¸ä½¿ç”¨ FluentValidation)
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request));
        }

        // å¯ä»¥åŠ å…¥ç°¡å–®çš„å±¬æ€§é©—è­‰
        ValidateRequest(request);

        return await next();
    }

    private static void ValidateRequest(TRequest request)
    {
        // ç°¡å–®é©—è­‰é‚è¼¯
        var properties = typeof(TRequest).GetProperties();
        foreach (var property in properties)
        {
            var value = property.GetValue(request);
            
            // æª¢æŸ¥å¿…å¡«å­—ä¸²
            if (property.PropertyType == typeof(string) && value is string strValue && string.IsNullOrWhiteSpace(strValue))
            {
                if (property.Name.Contains("Id") == false) // ID å¯èƒ½ç‚º 0
                {
                    throw new ArgumentException($"{property.Name} cannot be empty");
                }
            }
            
            // æª¢æŸ¥å¿…å¡«æ•¸å­—
            if (property.PropertyType == typeof(int) && value is int intValue && intValue <= 0)
            {
                if (property.Name.Contains("Id") || property.Name.Contains("UserId"))
                {
                    throw new ArgumentException($"{property.Name} must be greater than 0");
                }
            }
        }
    }
}

// æ•ˆèƒ½ç›£æ§è¡Œç‚º
public class PerformanceBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<PerformanceBehavior<TRequest, TResponse>> _logger;
    private readonly Stopwatch _timer;

    public PerformanceBehavior(ILogger<PerformanceBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
        _timer = new Stopwatch();
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        _timer.Start();

        var response = await next();

        _timer.Stop();

        var elapsedMilliseconds = _timer.ElapsedMilliseconds;

        if (elapsedMilliseconds > 500) // è¶…é 500ms è¨˜éŒ„è­¦å‘Š
        {
            var requestName = typeof(TRequest).Name;
            _logger.LogWarning("Long Running Request: {RequestName} ({ElapsedMilliseconds} ms) {@Request}",
                requestName, elapsedMilliseconds, request);
        }

        return response;
    }
}
```

### 3.3 æ ¸å¿ƒä»‹é¢å®šç¾©
```csharp
// å…±ç”¨ DTOs
public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Avatar { get; set; } = string.Empty;
    public bool IsActive { get; set; }
}

public class MessageDto
{
    public int Id { get; set; }
    public int SenderId { get; set; }
    public int ReceiverId { get; set; }
    public string Content { get; set; } = string.Empty;
    public string MessageType { get; set; } = "text";
    public bool IsRead { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ReadAt { get; set; }
}

// åˆ†é çµæœ
public class PagedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int Page { get; set; }
    public int Size { get; set; }
    public int TotalCount { get; set; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / Size);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPreviousPage => Page > 1;

    public PagedResult() { }

    public PagedResult(List<T> items, int page, int size, int totalCount)
    {
        Items = items;
        Page = page;
        Size = size;
        TotalCount = totalCount;
    }
}

// æ“ä½œçµæœ
public class SendMessageResult
{
    public bool IsSuccess { get; set; }
    public int MessageId { get; set; }
    public string ErrorMessage { get; set; } = string.Empty;

    public static SendMessageResult Success(int messageId) => new() { IsSuccess = true, MessageId = messageId };
    public static SendMessageResult Failure(string error) => new() { IsSuccess = false, ErrorMessage = error };
}

public class FriendRequestResult
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; } = string.Empty;

    public static FriendRequestResult Success() => new() { IsSuccess = true };
    public static FriendRequestResult Failure(string error) => new() { IsSuccess = false, ErrorMessage = error };
}

// å…±ç”¨ç•°å¸¸
public class ExternalServiceException : Exception
{
    public ExternalServiceException(string message, Exception innerException) 
        : base(message, innerException) { }
}
```

## 4. CQRS æ¨¡å¼è¨­è¨ˆ

### 4.1 æ‡‰ç”¨å±¤çµæ§‹
```
ChatRoom.Chat.Application/
â”œâ”€â”€ Commands/
â”‚   â”œâ”€â”€ SendMessage/
â”‚   â”‚   â””â”€â”€ SendMessageCommand.cs          # ç›´æ¥å¯¦ä½œ IRequest
â”‚   â”œâ”€â”€ SendFriendRequest/
â”‚   â”‚   â””â”€â”€ SendFriendRequestCommand.cs    # ç›´æ¥å¯¦ä½œ IRequest
â”‚   â””â”€â”€ AcceptFriendRequest/
â”‚       â””â”€â”€ AcceptFriendRequestCommand.cs  # ç›´æ¥å¯¦ä½œ IRequest
â”œâ”€â”€ Queries/
â”‚   â”œâ”€â”€ GetMessages/
â”‚   â”‚   â””â”€â”€ GetMessagesQuery.cs            # ç›´æ¥å¯¦ä½œ IRequest
â”‚   â”œâ”€â”€ GetFriends/
â”‚   â”‚   â””â”€â”€ GetFriendsQuery.cs             # ç›´æ¥å¯¦ä½œ IRequest
â”‚   â””â”€â”€ GetFriendRequests/
â”‚       â””â”€â”€ GetFriendRequestsQuery.cs      # ç›´æ¥å¯¦ä½œ IRequest
â”œâ”€â”€ Handlers/
â”‚   â”œâ”€â”€ SendMessageCommandHandler.cs       # ç›´æ¥å¯¦ä½œ IRequestHandler
â”‚   â”œâ”€â”€ GetMessagesQueryHandler.cs         # ç›´æ¥å¯¦ä½œ IRequestHandler
â”‚   â””â”€â”€ ...å…¶ä»– Handler
â”œâ”€â”€ DTOs/
â”‚   â”œâ”€â”€ MessageDto.cs
â”‚   â”œâ”€â”€ FriendDto.cs
â”‚   â””â”€â”€ FriendRequestDto.cs
â””â”€â”€ DependencyInjection.cs
```

### 4.2 æ‡‰ç”¨å±¤è¨»å†Š
```csharp
// ChatRoom.Chat.Application/DependencyInjection.cs
public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        // è¨»å†Š MediatRï¼ŒåŒ…å«æ‰€æœ‰ Handler
        services.AddMediatRWithBehaviors(Assembly.GetExecutingAssembly());
        
        return services;
    }
}
```

### 4.3 API å±¤ä½¿ç”¨
```csharp
// ChatRoom.Chat.API/Controllers/MessagesController.cs
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class MessagesController : ControllerBase
{
    private readonly IMediator _mediator;

    public MessagesController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task<IActionResult> SendMessage([FromBody] SendMessageRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new SendMessageCommand(userId, request.ReceiverId, request.Content);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }

    [HttpGet("{friendId}")]
    public async Task<IActionResult> GetMessages(int friendId, [FromQuery] int page = 1, [FromQuery] int size = 20)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetMessagesQuery(userId, friendId, page, size);
        var result = await _mediator.Send(query);
        
        return Ok(result);
    }

    [HttpPut("{messageId}/read")]
    public async Task<IActionResult> MarkAsRead(int messageId)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new MarkMessageAsReadCommand(messageId, userId);
        var result = await _mediator.Send(command);
        
        return Ok(result);
    }
}

// ChatRoom.Chat.API/Controllers/FriendsController.cs
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class FriendsController : ControllerBase
{
    private readonly IMediator _mediator;

    public FriendsController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    public async Task<IActionResult> GetFriends()
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetFriendsQuery(userId);
        var result = await _mediator.Send(query);
        
        return Ok(result);
    }

    [HttpPost("requests")]
    public async Task<IActionResult> SendFriendRequest([FromBody] SendFriendRequestRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new SendFriendRequestCommand(userId, request.ReceiverId);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }

    [HttpPut("requests/{requestId}/accept")]
    public async Task<IActionResult> AcceptFriendRequest(int requestId)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new AcceptFriendRequestCommand(requestId, userId);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }
}
```

## 5. è³‡æ–™åº«è¨­è¨ˆ

### 5.1 ç”¨æˆ¶æœå‹™è³‡æ–™åº«
```sql
-- ç”¨æˆ¶è¡¨
CREATE TABLE Users (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Username VARCHAR(50) UNIQUE NOT NULL,
    Email VARCHAR(100) UNIQUE NOT NULL,
    PasswordHash VARCHAR(255) NOT NULL,
    DisplayName VARCHAR(100) NOT NULL,
    Avatar VARCHAR(255) DEFAULT '',
    IsActive BOOLEAN DEFAULT TRUE,
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (Username),
    INDEX idx_email (Email),
    INDEX idx_active (IsActive)
);

-- åˆå§‹æ¸¬è©¦è³‡æ–™
INSERT INTO Users (Username, Email, PasswordHash, DisplayName) VALUES
('admin', 'admin@example.com', '$2a$11$hashed_password', 'ç®¡ç†å“¡'),
('user1', 'user1@example.com', '$2a$11$hashed_password', 'ä½¿ç”¨è€…1'),
('user2', 'user2@example.com', '$2a$11$hashed_password', 'ä½¿ç”¨è€…2');
```

### 5.2 èŠå¤©æœå‹™è³‡æ–™åº«
```sql
-- å¥½å‹é—œä¿‚è¡¨
CREATE TABLE Friends (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    RequesterId INT NOT NULL COMMENT 'ç™¼é€è«‹æ±‚è€…ID',
    ReceiverId INT NOT NULL COMMENT 'æ¥æ”¶è«‹æ±‚è€…ID',
    Status ENUM('pending', 'accepted', 'rejected', 'blocked') DEFAULT 'pending',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_friendship (RequesterId, ReceiverId),
    INDEX idx_requester_status (RequesterId, Status),
    INDEX idx_receiver_status (ReceiverId, Status)
);

-- ç§äººè¨Šæ¯è¡¨
CREATE TABLE Messages (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    SenderId INT NOT NULL COMMENT 'ç™¼é€è€…ID (0è¡¨ç¤ºæ©Ÿå™¨äºº)',
    ReceiverId INT NOT NULL COMMENT 'æ¥æ”¶è€…ID',
    Content TEXT NOT NULL COMMENT 'è¨Šæ¯å…§å®¹',
    MessageType ENUM('text', 'bot_reply') DEFAULT 'text',
    IsRead BOOLEAN DEFAULT FALSE COMMENT 'æ˜¯å¦å·²è®€',
    ReadAt DATETIME NULL COMMENT 'å·²è®€æ™‚é–“',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_conversation (SenderId, ReceiverId, CreatedAt),
    INDEX idx_receiver_unread (ReceiverId, IsRead),
    INDEX idx_created_at (CreatedAt)
);
```

### 5.3 é€šçŸ¥æœå‹™è³‡æ–™åº«
```sql
-- ç”¨æˆ¶é€£ç·šç‹€æ…‹è¡¨
CREATE TABLE UserConnections (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    UserId INT NOT NULL COMMENT 'ç”¨æˆ¶ID',
    ConnectionId VARCHAR(255) NOT NULL COMMENT 'SignalR é€£ç·šID',
    IsOnline BOOLEAN DEFAULT TRUE COMMENT 'æ˜¯å¦åœ¨ç·š',
    LastSeen DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT 'æœ€å¾Œæ´»èºæ™‚é–“',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_connection (ConnectionId),
    INDEX idx_user_online (UserId, IsOnline),
    INDEX idx_last_seen (LastSeen)
);
```

## 6. gRPC æœå‹™å¥‘ç´„

### 6.1 ç”¨æˆ¶æœå‹™å¥‘ç´„
```protobuf
// ChatRoom.Shared.Contracts/user.proto
syntax = "proto3";
option csharp_namespace = "ChatRoom.Shared.Contracts";

service UserService {
  rpc GetUser(GetUserRequest) returns (UserResponse);
  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse);
  rpc ValidateUser(ValidateUserRequest) returns (ValidateUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  rpc SearchUsers(SearchUsersRequest) returns (SearchUsersResponse);
}

message GetUserRequest {
  int32 user_id = 1;
}

message GetUsersRequest {
  repeated int32 user_ids = 1;
}

message UserResponse {
  int32 id = 1;
  string username = 2;
  string display_name = 3;
  string avatar = 4;
  bool is_active = 5;
  string created_at = 6;
}

message GetUsersResponse {
  repeated UserResponse users = 1;
}

message ValidateUserRequest {
  int32 user_id = 1;
}

message ValidateUserResponse {
  bool is_valid = 1;
  string error_message = 2;
}
```

### 6.2 èŠå¤©æœå‹™å¥‘ç´„
```protobuf
// ChatRoom.Shared.Contracts/chat.proto
syntax = "proto3";

service ChatService {
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
  rpc GetMessages(GetMessagesRequest) returns (GetMessagesResponse);
  rpc SendFriendRequest(SendFriendRequestRequest) returns (FriendRequestResponse);
  rpc AcceptFriendRequest(AcceptFriendRequestRequest) returns (FriendRequestResponse);
  rpc GetFriends(GetFriendsRequest) returns (GetFriendsResponse);
  rpc GetFriendRequests(GetFriendRequestsRequest) returns (GetFriendRequestsResponse);
}

message SendMessageRequest {
  int32 sender_id = 1;
  int32 receiver_id = 2;
  string content = 3;
  string message_type = 4;
}

message SendMessageResponse {
  bool success = 1;
  int32 message_id = 2;
  string error_message = 3;
}
```

## 7. ACL é˜²è…å±¤

### 7.1 gRPC Client ACL
```csharp
// ChatRoom.Shared.Infrastructure/GrpcClients/IUserGrpcClient.cs
public interface IUserGrpcClient
{
    Task<UserDto?> GetUserAsync(int userId);
    Task<List<UserDto>> GetUsersAsync(IEnumerable<int> userIds);
    Task<bool> ValidateUserAsync(int userId);
    Task<List<UserDto>> SearchUsersAsync(string keyword);
}

// ChatRoom.Shared.Infrastructure/GrpcClients/UserGrpcClient.cs
public class UserGrpcClient : IUserGrpcClient
{
    private readonly UserService.UserServiceClient _grpcClient;
    private readonly ILogger<UserGrpcClient> _logger;

    public UserGrpcClient(UserService.UserServiceClient grpcClient, ILogger<UserGrpcClient> logger)
    {
        _grpcClient = grpcClient;
        _logger = logger;
    }

    public async Task<UserDto?> GetUserAsync(int userId)
    {
        try
        {
            var request = new GetUserRequest { UserId = userId };
            var response = await _grpcClient.GetUserAsync(request);
            
            // ACL: å¤–éƒ¨æ¨¡å‹è½‰å…§éƒ¨æ¨¡å‹
            return new UserDto
            {
                Id = response.Id,
                Username = response.Username,
                DisplayName = response.DisplayName,
                Avatar = response.Avatar,
                IsActive = response.IsActive
            };
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.NotFound)
        {
            _logger.LogWarning("User {UserId} not found", userId);
            return null;
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to get user {UserId} via gRPC", userId);
            throw new ExternalServiceException("User service unavailable", ex);
        }
    }

    public async Task<List<UserDto>> GetUsersAsync(IEnumerable<int> userIds)
    {
        try
        {
            var request = new GetUsersRequest();
            request.UserIds.AddRange(userIds);
            
            var response = await _grpcClient.GetUsersAsync(request);
            
            return response.Users.Select(u => new UserDto
            {
                Id = u.Id,
                Username = u.Username,
                DisplayName = u.DisplayName,
                Avatar = u.Avatar,
                IsActive = u.IsActive
            }).ToList();
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to get users via gRPC");
            throw new ExternalServiceException("User service unavailable", ex);
        }
    }

    public async Task<bool> ValidateUserAsync(int userId)
    {
        try
        {
            var request = new ValidateUserRequest { UserId = userId };
            var response = await _grpcClient.ValidateUserAsync(request);
            return response.IsValid;
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to validate user {UserId}", userId);
            return false;
        }
    }

    public async Task<List<UserDto>> SearchUsersAsync(string keyword)
    {
        try
        {
            var request = new SearchUsersRequest { Keyword = keyword };
            var response = await _grpcClient.SearchUsersAsync(request);
            
            return response.Users.Select(u => new UserDto
            {
                Id = u.Id,
                Username = u.Username,
                DisplayName = u.DisplayName,
                Avatar = u.Avatar,
                IsActive = u.IsActive
            }).ToList();
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to search users with keyword {Keyword}", keyword);
            return new List<UserDto>();
        }
    }
}
```

### 7.2 HTTP Client ACL
```csharp
// ChatRoom.Shared.Infrastructure/HttpClients/INotificationHttpClient.cs
public interface INotificationHttpClient
{
    Task<bool> SendNotificationAsync(int userId, string message, string type);
    Task<bool> SendBulkNotificationAsync(IEnumerable<int> userIds, string message, string type);
}

// ChatRoom.Shared.Infrastructure/HttpClients/NotificationHttpClient.cs
public class NotificationHttpClient : INotificationHttpClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<NotificationHttpClient> _logger;

    public NotificationHttpClient(HttpClient httpClient, ILogger<NotificationHttpClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<bool> SendNotificationAsync(int userId, string message, string type)
    {
        try
        {
            var request = new
            {
                UserId = userId,
                Message = message,
                Type = type,
                Timestamp = DateTime.UtcNow
            };

            var json = JsonSerializer.Serialize(request, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _httpClient.PostAsync("/api/notifications", content);
            
            if (response.IsSuccessStatusCode)
            {
                _logger.LogDebug("Notification sent successfully to user {UserId}", userId);
                return true;
            }
            
            _logger.LogWarning("Failed to send notification to user {UserId}. Status: {StatusCode}", 
                userId, response.StatusCode);
            return false;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error when sending notification to user {UserId}", userId);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error when sending notification to user {UserId}", userId);
            return false;
        }
    }

    public async Task<bool> SendBulkNotificationAsync(IEnumerable<int> userIds, string message, string type)
    {
        try
        {
            var request = new
            {
                UserIds = userIds,
                Message = message,
                Type = type,
                Timestamp = DateTime.UtcNow
            };

            var json = JsonSerializer.Serialize(request, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _httpClient.PostAsync("/api/notifications/bulk", content);
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending bulk notifications");
            return false;
        }
    }
}
```

## 8. JWT èªè­‰æ¶æ§‹

### 8.1 JWT Token æœå‹™
```csharp
// ChatRoom.Shared.Infrastructure/Authentication/JwtTokenService.cs
public class JwtTokenService
{
    private readonly JwtSettings _settings;
    private readonly SymmetricSecurityKey _signingKey;

    public JwtTokenService(IOptions<JwtSettings> settings)
    {
        _settings = settings.Value;
        _signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.Secret));
    }

    public string GenerateToken(UserTokenInfo user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim("display_name", user.DisplayName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim(JwtRegisteredClaimNames.Iat, 
                DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
        };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddHours(_settings.ExpiryHours),
            SigningCredentials = new SigningCredentials(_signingKey, SecurityAlgorithms.HmacSha256),
            Issuer = _settings.Issuer,
            Audience = _settings.Audience
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }

    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = _settings.Issuer,
            ValidAudience = _settings.Audience,
            IssuerSigningKey = _signingKey,
            ClockSkew = TimeSpan.Zero
        };

        var principal = tokenHandler.ValidateToken(token, validationParameters, out _);
        return principal;
    }
}

// JWT è¨­å®š
public class JwtSettings
{
    public const string SectionName = "JwtSettings";
    
    public string Secret { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public int ExpiryHours { get; set; } = 24;
}

public class UserTokenInfo
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
}
```

## 9. SignalR å³æ™‚é€šè¨Š

### 9.1 Chat Hub è¨­è¨ˆ
```csharp
// ChatRoom.Notification.API/Hubs/ChatHub.cs
[Authorize]
public class ChatHub : Hub
{
    private readonly IMediator _mediator;
    private readonly ILogger<ChatHub> _logger;

    public ChatHub(IMediator mediator, ILogger<ChatHub> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    public async Task JoinUserGroup()
    {
        var userId = int.Parse(Context.UserIdentifier!);
        await Groups.AddToGroupAsync(Context.ConnectionId, $"user_{userId}");
        
        // ä½¿ç”¨ MediatR æ›´æ–°é€£ç·šç‹€æ…‹
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, true);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} joined with connection {ConnectionId}", userId, Context.ConnectionId);
    }

    public async Task SendMessage(int receiverId, string message)
    {
        var senderId = int.Parse(Context.UserIdentifier!);
        
        try
        {
            // ä½¿ç”¨ MediatR ç™¼é€è¨Šæ¯å‘½ä»¤
            var command = new SendMessageCommand(senderId, receiverId, message);
            var result = await _mediator.Send(command);

            if (result.IsSuccess)
            {
                // å³æ™‚æ¨é€çµ¦æ¥æ”¶è€…
                await Clients.Group($"user_{receiverId}")
                    .SendAsync("ReceiveMessage", new
                    {
                        MessageId = result.MessageId,
                        SenderId = senderId,
                        Content = message,
                        MessageType = "text",
                        Timestamp = DateTime.UtcNow
                    });

                // æ©Ÿå™¨äººå›è¦†ä¹Ÿæ¨é€çµ¦ç™¼é€è€…
                await Clients.Group($"user_{senderId}")
                    .SendAsync("ReceiveMessage", new
                    {
                        MessageId = result.MessageId + 1, // æ©Ÿå™¨äººè¨Šæ¯ ID
                        SenderId = 0, // Bot ID
                        Content = $"Bot: {message}",
                        MessageType = "bot_reply",
                        Timestamp = DateTime.UtcNow
                    });

                // å›è¦†ç™¼é€è€…ç¢ºèª
                await Clients.Caller.SendAsync("MessageSent", new { MessageId = result.MessageId });
            }
            else
            {
                await Clients.Caller.SendAsync("MessageError", result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending message from {SenderId} to {ReceiverId}", senderId, receiverId);
            await Clients.Caller.SendAsync("MessageError", "ç™¼é€è¨Šæ¯å¤±æ•—");
        }
    }

    public async Task MarkMessageAsRead(int messageId)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        
        try
        {
            // ä½¿ç”¨ MediatR æ¨™è¨˜å·²è®€
            var command = new MarkMessageAsReadCommand(messageId, userId);
            await _mediator.Send(command);

            // é€šçŸ¥ç›¸é—œç”¨æˆ¶è¨Šæ¯å·²è®€
            await Clients.All.SendAsync("MessageRead", new { MessageId = messageId, ReadBy = userId });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error marking message {MessageId} as read by user {UserId}", messageId, userId);
        }
    }

    public override async Task OnConnectedAsync()
    {
        var userId = Context.UserIdentifier;
        _logger.LogInformation("User {UserId} connected with {ConnectionId}", userId, Context.ConnectionId);
        
        await JoinUserGroup();
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        
        // ä½¿ç”¨ MediatR æ›´æ–°é€£ç·šç‹€æ…‹
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, false);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} disconnected from {ConnectionId}", userId, Context.ConnectionId);
        await base.OnDisconnectedAsync(exception);
    }
}
```

## 10. Docker éƒ¨ç½²

### 10.1 Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  # è³‡æ–™åº«
  mysql:
    image: mysql:8.0
    container_name: chatroom-mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: chatroom
      MYSQL_CHARACTER_SET_SERVER: utf8mb4
      MYSQL_COLLATION_SERVER: utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/migrations:/docker-entrypoint-initdb.d
    networks:
      - chatroom-network
    restart: unless-stopped

  # ç”¨æˆ¶æœå‹™
  user-service:
    build:
      context: .
      dockerfile: src/Services/User/ChatRoom.User.API/Dockerfile
    container_name: chatroom-user-service
    ports:
      - "5001:80"
      - "5101:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_user;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - JwtSettings__Secret=your-super-secret-jwt-signing-key-that-is-long-enough-256-bits
      - JwtSettings__Issuer=ChatRoomApp
      - JwtSettings__Audience=ChatRoomUsers
      - JwtSettings__ExpiryHours=24
    depends_on:
      - mysql
    networks:
      - chatroom-network
    restart: unless-stopped

  # èŠå¤©æœå‹™
  chat-service:
    build:
      context: .
      dockerfile: src/Services/Chat/ChatRoom.Chat.API/Dockerfile
    container_name: chatroom-chat-service
    ports:
      - "5002:80"
      - "5102:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_chat;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - Services__UserService__GrpcUrl=https://user-service:443
      - Services__NotificationService__HttpUrl=http://notification-service:80
    depends_on:
      - mysql
      - user-service
    networks:
      - chatroom-network
    restart: unless-stopped

  # é€šçŸ¥æœå‹™
  notification-service:
    build:
      context: .
      dockerfile: src/Services/Notification/ChatRoom.Notification.API/Dockerfile
    container_name: chatroom-notification-service
    ports:
      - "5003:80"
      - "5103:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_notification;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - Services__UserService__GrpcUrl=https://user-service:443
      - Services__ChatService__GrpcUrl=https://chat-service:443
      - JwtSettings__Secret=your-super-secret-jwt-signing-key-that-is-long-enough-256-bits
      - JwtSettings__Issuer=ChatRoomApp
      - JwtSettings__Audience=ChatRoomUsers
    depends_on:
      - mysql
      - user-service
    networks:
      - chatroom-network
    restart: unless-stopped

  # API é–˜é“
  api-gateway:
    build:
      context: .
      dockerfile: src/ApiGateway/ChatRoom.Gateway/Dockerfile
    container_name: chatroom-api-gateway
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - Services__UserService__Url=http://user-service:80
      - Services__ChatService__Url=http://chat-service:80
      - Services__NotificationService__Url=http://notification-service:80
    depends_on:
      - user-service
      - chat-service
      - notification-service
    networks:
      - chatroom-network
    restart: unless-stopped

volumes:
  mysql_data:
    driver: local

networks:
  chatroom-network:
    driver: bridge
```

### 10.2 è³‡æ–™åº«åˆå§‹åŒ–è…³æœ¬
```sql
-- database/migrations/01_create_databases.sql
CREATE DATABASE IF NOT EXISTS chatroom_user CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS chatroom_chat CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS chatroom_notification CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- å»ºç«‹ç”¨æˆ¶
CREATE USER IF NOT EXISTS 'chatroom_user'@'%' IDENTIFIED BY 'chatroom_password';
GRANT ALL PRIVILEGES ON chatroom_user.* TO 'chatroom_user'@'%';
GRANT ALL PRIVILEGES ON chatroom_chat.* TO 'chatroom_user'@'%';
GRANT ALL PRIVILEGES ON chatroom_notification.* TO 'chatroom_user'@'%';
FLUSH PRIVILEGES;
```

## 11. é–‹ç™¼è¦ç¯„

### 11.1 MediatR ä½¿ç”¨è¦ç¯„

**âŒ éŒ¯èª¤åšæ³• - ä¸è¦äºŒæ¬¡å°è£ MediatR:**
```csharp
// ä¸è¦é€™æ¨£åš
public interface ICommand<out TResponse> : IRequest<TResponse> { }
public interface ICommandHandler<in TCommand, TResponse> : IRequestHandler<TCommand, TResponse>
    where TCommand : ICommand<TResponse> { }

public class SendMessageCommand : ICommand<SendMessageResult> // ä¸è¦å¤šæ­¤ä¸€èˆ‰
```

**âœ… æ­£ç¢ºåšæ³• - ç›´æ¥ä½¿ç”¨ MediatR:**
```csharp
// ç›´æ¥ä½¿ç”¨ MediatR ä»‹é¢
public record SendMessageCommand(int SenderId, int ReceiverId, string Content) : IRequest<SendMessageResult>;

public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    // å¯¦ä½œé‚è¼¯...
}
```

### 11.2 å‘½åè¦ç¯„
- **å°ˆæ¡ˆå‘½å**: `ChatRoom.{Service}.{Layer}`
- **æª”æ¡ˆå‘½å**: PascalCase
- **ä»‹é¢å‘½å**: ä»¥ `I` é–‹é ­
- **å¸¸æ•¸å‘½å**: UPPER_SNAKE_CASE
- **æ–¹æ³•å‘½å**: PascalCaseï¼ŒAsync æ–¹æ³•ä»¥ `Async` çµå°¾

### 11.3 éŒ¯èª¤è™•ç†
```csharp
// å…¨åŸŸç•°å¸¸è™•ç†ä¸­ä»‹è»Ÿé«”
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var response = exception switch
        {
            ExternalServiceException => new { error = "External service error", message = exception.Message, statusCode = 503 },
            ArgumentException => new { error = "Invalid request", message = exception.Message, statusCode = 400 },
            UnauthorizedAccessException => new { error = "Unauthorized", message = "Access denied", statusCode = 401 },
            _ => new { error = "Internal server error", message = "An error occurred", statusCode = 500 }
        };

        context.Response.StatusCode = response.statusCode;
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 11.4 æ—¥èªŒè¦ç¯„
```csharp
// çµæ§‹åŒ–æ—¥èªŒç¯„ä¾‹
public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    private readonly ILogger<SendMessageCommandHandler> _logger;

    public async Task<SendMessageResult> Handle(SendMessageCommand request, CancellationToken cancellationToken)
    {
        using var scope = _logger.BeginScope(new Dictionary<string, object>
        {
            ["SenderId"] = request.SenderId,
            ["ReceiverId"] = request.ReceiverId
        });

        _logger.LogInformation("Processing send message command");

        try
        {
            // æ¥­å‹™é‚è¼¯...
            _logger.LogInformation("Message sent successfully with ID {MessageId}", messageId);
            return SendMessageResult.Success(messageId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send message");
            throw;
        }
    }
}
```

### 11.5 æ¸¬è©¦è¦ç¯„
```csharp
// å–®å…ƒæ¸¬è©¦ç¯„ä¾‹
public class SendMessageCommandHandlerTests
{
    private readonly Mock<IMessageRepository> _mockMessageRepository;
    private readonly Mock<IUserGrpcClient> _mockUserGrpcClient;
    private readonly SendMessageCommandHandler _handler;

    public SendMessageCommandHandlerTests()
    {
        _mockMessageRepository = new Mock<IMessageRepository>();
        _mockUserGrpcClient = new Mock<IUserGrpcClient>();
        _handler = new SendMessageCommandHandler(
            _mockMessageRepository.Object,
            _mockUserGrpcClient.Object,
            Mock.Of<INotificationHttpClient>(),
            Mock.Of<ILogger<SendMessageCommandHandler>>());
    }

    [Fact]
    public async Task Handle_ValidRequest_ReturnsSuccess()
    {
        // Arrange
        var command = new SendMessageCommand(1, 2, "Hello");
        _mockUserGrpcClient.Setup(x => x.GetUserAsync(It.IsAny<int>()))
            .ReturnsAsync(new UserDto { Id = 1, IsActive = true });
        _mockMessageRepository.Setup(x => x.CreateAsync(It.IsAny<Message>()))
            .ReturnsAsync(123);

        // Act
        var result = await _handler.Handle(command, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(123, result.MessageId);
    }
}
```

---

**æ–‡ä»¶ç‰ˆæœ¬**: 1.0  
**æœ€å¾Œæ›´æ–°**: 2025-06-08  
**ç¶­è­·è€…**: é–‹ç™¼åœ˜éšŠ

**é‡è¦æé†’**: 
- ç›´æ¥ä½¿ç”¨ MediatR çš„ `IRequest` å’Œ `IRequestHandler` ä»‹é¢
- ä¸è¦å»ºç«‹é¡å¤–çš„æŠ½è±¡å±¤å¦‚ `ICommand` æˆ– `IQuery`
- ä¿æŒæ¶æ§‹ç°¡æ½”ï¼Œå°ˆæ³¨æ–¼æ¥­å‹™é‚è¼¯å¯¦ç¾
