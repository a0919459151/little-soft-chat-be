# 聊天室後端架構設計文件
**版本**: 1.0  
**日期**: 2025-06-08  
**技術棧**: .NET 8 + gRPC + SignalR + MySQL 8

## 📋 目錄
- [1. 架構概覽](#1-架構概覽)
- [2. 微服務設計](#2-微服務設計)
- [3. 共享內核 (Shared Kernel)](#3-共享內核-shared-kernel)
- [4. CQRS 模式設計](#4-cqrs-模式設計)
- [5. 資料庫設計](#5-資料庫設計)
- [6. gRPC 服務契約](#6-grpc-服務契約)
- [7. ACL 防腐層](#7-acl-防腐層)
- [8. JWT 認證架構](#8-jwt-認證架構)
- [9. SignalR 即時通訊](#9-signalr-即時通訊)
- [10. Docker 部署](#10-docker-部署)
- [11. 開發規範](#11-開發規範)

## 1. 架構概覽

### 1.1 專案結構
```
chat-room-backend/
├── src/
│   ├── ApiGateway/                       # API 閘道
│   │   └── ChatRoom.Gateway/
│   ├── Services/                         # 微服務
│   │   ├── User/                         # 用戶服務
│   │   │   ├── ChatRoom.User.API/
│   │   │   ├── ChatRoom.User.Application/
│   │   │   ├── ChatRoom.User.Domain/
│   │   │   └── ChatRoom.User.Infrastructure/
│   │   ├── Chat/                         # 聊天服務
│   │   │   ├── ChatRoom.Chat.API/
│   │   │   ├── ChatRoom.Chat.Application/
│   │   │   ├── ChatRoom.Chat.Domain/
│   │   │   └── ChatRoom.Chat.Infrastructure/
│   │   └── Notification/                 # 通知服務
│   │       ├── ChatRoom.Notification.API/
│   │       ├── ChatRoom.Notification.Application/
│   │       ├── ChatRoom.Notification.Domain/
│   │       └── ChatRoom.Notification.Infrastructure/
│   └── Shared/                           # 共享內核
│       ├── ChatRoom.Shared.Contracts/    # gRPC 契約
│       ├── ChatRoom.Shared.Domain/       # 共用領域模型
│       └── ChatRoom.Shared.Infrastructure/ # 共用基礎設施
├── database/                             # 資料庫腳本
├── docker-compose.yml
└── README.md
```

### 1.2 服務職責劃分

| 服務 | 端口 | 職責 | 技術特點 |
|------|------|------|----------|
| **User Service** | 5001/5101 | 用戶認證、個人資料管理 | JWT 認證、gRPC |
| **Chat Service** | 5002/5102 | 好友管理、私人訊息、機器人 | CQRS、gRPC |
| **Notification Service** | 5003/5103 | 即時通訊、推送通知 | SignalR、gRPC |
| **API Gateway** | 5000 | 路由、負載平衡 | HTTP 轉發 |

## 2. 微服務設計

### 2.1 用戶服務 (User Service)

**核心職責:**
- JWT Token 生成與驗證
- 用戶個人資料 CRUD
- 用戶搜尋功能

**API 設計:**
```csharp
// HTTP API
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        var command = new LoginCommand(request.Username, request.Password);
        var result = await _mediator.Send(command);
        return Ok(result);
    }
    
    [HttpGet("profile")]
    [Authorize]
    public async Task<IActionResult> GetProfile()
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetUserProfileQuery(userId);
        var result = await _mediator.Send(query);
        return Ok(result);
    }
    
    [HttpPut("profile")]
    [Authorize]
    public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new UpdateUserProfileCommand(userId, request.DisplayName, request.Avatar);
        var result = await _mediator.Send(command);
        return Ok(result);
    }
}

// gRPC Service
public class UserGrpcService : UserService.UserServiceBase
{
    private readonly IMediator _mediator;

    public override async Task<GetUserResponse> GetUser(GetUserRequest request, ServerCallContext context)
    {
        var query = new GetUserByIdQuery(request.UserId);
        var user = await _mediator.Send(query);
        
        return new GetUserResponse
        {
            Id = user.Id,
            Username = user.Username,
            DisplayName = user.DisplayName,
            Avatar = user.Avatar,
            IsActive = user.IsActive
        };
    }

    public override async Task<GetUsersResponse> GetUsers(GetUsersRequest request, ServerCallContext context)
    {
        var query = new GetUsersByIdsQuery(request.UserIds.ToList());
        var users = await _mediator.Send(query);
        
        var response = new GetUsersResponse();
        response.Users.AddRange(users.Select(u => new UserResponse
        {
            Id = u.Id,
            Username = u.Username,
            DisplayName = u.DisplayName,
            Avatar = u.Avatar,
            IsActive = u.IsActive
        }));
        
        return response;
    }
}
```

### 2.2 聊天服務 (Chat Service)

**核心職責:**
- 好友關係管理 (邀請、接受、拒絕)
- 私人訊息處理
- 機器人回覆邏輯

**CQRS 設計:**
```csharp
// Commands (寫操作) - 直接使用 MediatR IRequest
public record SendMessageCommand(int SenderId, int ReceiverId, string Content) : IRequest<SendMessageResult>;

public record SendFriendRequestCommand(int RequesterId, int ReceiverId) : IRequest<FriendRequestResult>;

public record AcceptFriendRequestCommand(int FriendshipId, int UserId) : IRequest<FriendRequestResult>;

// Queries (讀操作) - 直接使用 MediatR IRequest  
public record GetMessagesQuery(int UserId, int FriendId, int Page, int Size) : IRequest<PagedResult<MessageDto>>;

public record GetFriendsQuery(int UserId) : IRequest<List<FriendDto>>;

public record GetFriendRequestsQuery(int UserId) : IRequest<List<FriendRequestDto>>;

// Command Handlers - 直接實作 MediatR IRequestHandler
public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    private readonly IMessageRepository _messageRepository;
    private readonly IUserGrpcClient _userGrpcClient;
    private readonly INotificationHttpClient _notificationHttpClient;
    private readonly ILogger<SendMessageCommandHandler> _logger;

    public SendMessageCommandHandler(
        IMessageRepository messageRepository,
        IUserGrpcClient userGrpcClient,
        INotificationHttpClient notificationHttpClient,
        ILogger<SendMessageCommandHandler> logger)
    {
        _messageRepository = messageRepository;
        _userGrpcClient = userGrpcClient;
        _notificationHttpClient = notificationHttpClient;
        _logger = logger;
    }

    public async Task<SendMessageResult> Handle(SendMessageCommand request, CancellationToken cancellationToken)
    {
        // 1. 驗證用戶 (通過 gRPC)
        var sender = await _userGrpcClient.GetUserAsync(request.SenderId);
        var receiver = await _userGrpcClient.GetUserAsync(request.ReceiverId);

        if (sender == null || receiver == null || !sender.IsActive || !receiver.IsActive)
        {
            return SendMessageResult.Failure("Invalid users");
        }

        // 2. 保存訊息
        var message = new Message
        {
            SenderId = request.SenderId,
            ReceiverId = request.ReceiverId,
            Content = request.Content,
            MessageType = "text",
            CreatedAt = DateTime.UtcNow
        };

        var messageId = await _messageRepository.CreateAsync(message);

        // 3. 機器人回覆 (第一階段：重複內容)
        var botReply = new Message
        {
            SenderId = 0, // Bot ID
            ReceiverId = request.SenderId,
            Content = $"Bot: {request.Content}",
            MessageType = "bot_reply",
            CreatedAt = DateTime.UtcNow
        };

        await _messageRepository.CreateAsync(botReply);

        // 4. 發送通知 (非同步，不影響主流程)
        _ = Task.Run(async () =>
        {
            try
            {
                await _notificationHttpClient.SendNotificationAsync(
                    request.ReceiverId,
                    $"來自 {sender.DisplayName} 的新訊息",
                    "new_message"
                );
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to send notification for message {MessageId}", messageId);
            }
        }, cancellationToken);

        return SendMessageResult.Success(messageId);
    }
}

// Query Handlers - 直接實作 MediatR IRequestHandler
public class GetMessagesQueryHandler : IRequestHandler<GetMessagesQuery, PagedResult<MessageDto>>
{
    private readonly IDbConnectionFactory _dbFactory;

    public GetMessagesQueryHandler(IDbConnectionFactory dbFactory)
    {
        _dbFactory = dbFactory;
    }

    public async Task<PagedResult<MessageDto>> Handle(GetMessagesQuery request, CancellationToken cancellationToken)
    {
        using var connection = _dbFactory.CreateConnection();
        
        var sql = @"
            SELECT Id, SenderId, ReceiverId, Content, MessageType, IsRead, CreatedAt
            FROM Messages 
            WHERE (SenderId = @UserId AND ReceiverId = @FriendId) 
               OR (SenderId = @FriendId AND ReceiverId = @UserId)
            ORDER BY CreatedAt DESC
            LIMIT @Offset, @Size";

        var messages = await connection.QueryAsync<MessageDto>(sql, new
        {
            UserId = request.UserId,
            FriendId = request.FriendId,
            Offset = (request.Page - 1) * request.Size,
            Size = request.Size
        });

        var totalSql = @"
            SELECT COUNT(*)
            FROM Messages 
            WHERE (SenderId = @UserId AND ReceiverId = @FriendId) 
               OR (SenderId = @FriendId AND ReceiverId = @UserId)";

        var total = await connection.QuerySingleAsync<int>(totalSql, new
        {
            UserId = request.UserId,
            FriendId = request.FriendId
        });

        return new PagedResult<MessageDto>(messages.ToList(), request.Page, request.Size, total);
    }
}
```

### 2.3 通知服務 (Notification Service)

**核心職責:**
- SignalR Hub 管理
- 用戶連線狀態追蹤
- 即時推送通知

**MediatR 整合:**
```csharp
// Commands
public record SendNotificationCommand(int UserId, string Message, string Type) : IRequest<bool>;

public record UpdateUserConnectionCommand(int UserId, string ConnectionId, bool IsOnline) : IRequest;

// Command Handlers
public class SendNotificationCommandHandler : IRequestHandler<SendNotificationCommand, bool>
{
    private readonly IHubContext<ChatHub> _hubContext;
    private readonly IUserConnectionRepository _connectionRepository;

    public async Task<bool> Handle(SendNotificationCommand request, CancellationToken cancellationToken)
    {
        var connections = await _connectionRepository.GetUserConnectionsAsync(request.UserId);
        
        if (connections.Any())
        {
            await _hubContext.Clients.Clients(connections)
                .SendAsync("ReceiveNotification", new
                {
                    Message = request.Message,
                    Type = request.Type,
                    Timestamp = DateTime.UtcNow
                }, cancellationToken);
            return true;
        }
        
        return false;
    }
}

// SignalR Hub
[Authorize]
public class ChatHub : Hub
{
    private readonly IMediator _mediator;
    private readonly ILogger<ChatHub> _logger;

    public ChatHub(IMediator mediator, ILogger<ChatHub> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    public async Task JoinUserGroup()
    {
        var userId = int.Parse(Context.UserIdentifier!);
        await Groups.AddToGroupAsync(Context.ConnectionId, $"user_{userId}");
        
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, true);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} joined with connection {ConnectionId}", userId, Context.ConnectionId);
    }

    public async Task SendMessage(int receiverId, string message)
    {
        var senderId = int.Parse(Context.UserIdentifier!);
        
        var command = new SendMessageCommand(senderId, receiverId, message);
        var result = await _mediator.Send(command);

        if (result.IsSuccess)
        {
            await Clients.Group($"user_{receiverId}")
                .SendAsync("ReceiveMessage", new
                {
                    MessageId = result.MessageId,
                    SenderId = senderId,
                    Content = message,
                    MessageType = "text",
                    Timestamp = DateTime.UtcNow
                });

            await Clients.Caller.SendAsync("MessageSent", new { MessageId = result.MessageId });
        }
        else
        {
            await Clients.Caller.SendAsync("MessageError", result.ErrorMessage);
        }
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, false);
        await _mediator.Send(command);
        
        await base.OnDisconnectedAsync(exception);
    }
}
```

## 3. 共享內核 (Shared Kernel)

### 3.1 結構設計
```
ChatRoom.Shared.Infrastructure/
├── GrpcClients/                  # gRPC 客戶端 (ACL)
├── HttpClients/                  # HTTP 客戶端 (ACL)
├── Authentication/               # JWT 認證模組
├── Database/                     # 資料庫通用功能
├── Logging/                      # 日誌模組
├── HealthChecks/                 # 健康檢查
├── Extensions/                   # 擴展方法
└── DependencyInjection.cs       # 統一註冊
```

### 3.2 MediatR 配置
```csharp
// ChatRoom.Shared.Infrastructure/Extensions/MediatRExtensions.cs
public static class MediatRExtensions
{
    public static IServiceCollection AddMediatRWithBehaviors(this IServiceCollection services, Assembly assembly)
    {
        // 註冊 MediatR
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(assembly));
        
        // 註冊 Pipeline Behaviors
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(PerformanceBehavior<,>));
        
        return services;
    }
}

// 日誌行為
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;

    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        _logger.LogInformation("Handling {RequestName} with {@Request}", requestName, request);

        try
        {
            var response = await next();
            _logger.LogInformation("Completed {RequestName}", requestName);
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling {RequestName}", requestName);
            throw;
        }
    }
}

// 驗證行為
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        // 基本驗證邏輯 (不使用 FluentValidation)
        if (request == null)
        {
            throw new ArgumentNullException(nameof(request));
        }

        // 可以加入簡單的屬性驗證
        ValidateRequest(request);

        return await next();
    }

    private static void ValidateRequest(TRequest request)
    {
        // 簡單驗證邏輯
        var properties = typeof(TRequest).GetProperties();
        foreach (var property in properties)
        {
            var value = property.GetValue(request);
            
            // 檢查必填字串
            if (property.PropertyType == typeof(string) && value is string strValue && string.IsNullOrWhiteSpace(strValue))
            {
                if (property.Name.Contains("Id") == false) // ID 可能為 0
                {
                    throw new ArgumentException($"{property.Name} cannot be empty");
                }
            }
            
            // 檢查必填數字
            if (property.PropertyType == typeof(int) && value is int intValue && intValue <= 0)
            {
                if (property.Name.Contains("Id") || property.Name.Contains("UserId"))
                {
                    throw new ArgumentException($"{property.Name} must be greater than 0");
                }
            }
        }
    }
}

// 效能監控行為
public class PerformanceBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<PerformanceBehavior<TRequest, TResponse>> _logger;
    private readonly Stopwatch _timer;

    public PerformanceBehavior(ILogger<PerformanceBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
        _timer = new Stopwatch();
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        _timer.Start();

        var response = await next();

        _timer.Stop();

        var elapsedMilliseconds = _timer.ElapsedMilliseconds;

        if (elapsedMilliseconds > 500) // 超過 500ms 記錄警告
        {
            var requestName = typeof(TRequest).Name;
            _logger.LogWarning("Long Running Request: {RequestName} ({ElapsedMilliseconds} ms) {@Request}",
                requestName, elapsedMilliseconds, request);
        }

        return response;
    }
}
```

### 3.3 核心介面定義
```csharp
// 共用 DTOs
public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Avatar { get; set; } = string.Empty;
    public bool IsActive { get; set; }
}

public class MessageDto
{
    public int Id { get; set; }
    public int SenderId { get; set; }
    public int ReceiverId { get; set; }
    public string Content { get; set; } = string.Empty;
    public string MessageType { get; set; } = "text";
    public bool IsRead { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ReadAt { get; set; }
}

// 分頁結果
public class PagedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int Page { get; set; }
    public int Size { get; set; }
    public int TotalCount { get; set; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / Size);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPreviousPage => Page > 1;

    public PagedResult() { }

    public PagedResult(List<T> items, int page, int size, int totalCount)
    {
        Items = items;
        Page = page;
        Size = size;
        TotalCount = totalCount;
    }
}

// 操作結果
public class SendMessageResult
{
    public bool IsSuccess { get; set; }
    public int MessageId { get; set; }
    public string ErrorMessage { get; set; } = string.Empty;

    public static SendMessageResult Success(int messageId) => new() { IsSuccess = true, MessageId = messageId };
    public static SendMessageResult Failure(string error) => new() { IsSuccess = false, ErrorMessage = error };
}

public class FriendRequestResult
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; } = string.Empty;

    public static FriendRequestResult Success() => new() { IsSuccess = true };
    public static FriendRequestResult Failure(string error) => new() { IsSuccess = false, ErrorMessage = error };
}

// 共用異常
public class ExternalServiceException : Exception
{
    public ExternalServiceException(string message, Exception innerException) 
        : base(message, innerException) { }
}
```

## 4. CQRS 模式設計

### 4.1 應用層結構
```
ChatRoom.Chat.Application/
├── Commands/
│   ├── SendMessage/
│   │   └── SendMessageCommand.cs          # 直接實作 IRequest
│   ├── SendFriendRequest/
│   │   └── SendFriendRequestCommand.cs    # 直接實作 IRequest
│   └── AcceptFriendRequest/
│       └── AcceptFriendRequestCommand.cs  # 直接實作 IRequest
├── Queries/
│   ├── GetMessages/
│   │   └── GetMessagesQuery.cs            # 直接實作 IRequest
│   ├── GetFriends/
│   │   └── GetFriendsQuery.cs             # 直接實作 IRequest
│   └── GetFriendRequests/
│       └── GetFriendRequestsQuery.cs      # 直接實作 IRequest
├── Handlers/
│   ├── SendMessageCommandHandler.cs       # 直接實作 IRequestHandler
│   ├── GetMessagesQueryHandler.cs         # 直接實作 IRequestHandler
│   └── ...其他 Handler
├── DTOs/
│   ├── MessageDto.cs
│   ├── FriendDto.cs
│   └── FriendRequestDto.cs
└── DependencyInjection.cs
```

### 4.2 應用層註冊
```csharp
// ChatRoom.Chat.Application/DependencyInjection.cs
public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        // 註冊 MediatR，包含所有 Handler
        services.AddMediatRWithBehaviors(Assembly.GetExecutingAssembly());
        
        return services;
    }
}
```

### 4.3 API 層使用
```csharp
// ChatRoom.Chat.API/Controllers/MessagesController.cs
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class MessagesController : ControllerBase
{
    private readonly IMediator _mediator;

    public MessagesController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task<IActionResult> SendMessage([FromBody] SendMessageRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new SendMessageCommand(userId, request.ReceiverId, request.Content);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }

    [HttpGet("{friendId}")]
    public async Task<IActionResult> GetMessages(int friendId, [FromQuery] int page = 1, [FromQuery] int size = 20)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetMessagesQuery(userId, friendId, page, size);
        var result = await _mediator.Send(query);
        
        return Ok(result);
    }

    [HttpPut("{messageId}/read")]
    public async Task<IActionResult> MarkAsRead(int messageId)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new MarkMessageAsReadCommand(messageId, userId);
        var result = await _mediator.Send(command);
        
        return Ok(result);
    }
}

// ChatRoom.Chat.API/Controllers/FriendsController.cs
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class FriendsController : ControllerBase
{
    private readonly IMediator _mediator;

    public FriendsController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    public async Task<IActionResult> GetFriends()
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var query = new GetFriendsQuery(userId);
        var result = await _mediator.Send(query);
        
        return Ok(result);
    }

    [HttpPost("requests")]
    public async Task<IActionResult> SendFriendRequest([FromBody] SendFriendRequestRequest request)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new SendFriendRequestCommand(userId, request.ReceiverId);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }

    [HttpPut("requests/{requestId}/accept")]
    public async Task<IActionResult> AcceptFriendRequest(int requestId)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value!);
        var command = new AcceptFriendRequestCommand(requestId, userId);
        var result = await _mediator.Send(command);
        
        return result.IsSuccess ? Ok(result) : BadRequest(result);
    }
}
```

## 5. 資料庫設計

### 5.1 用戶服務資料庫
```sql
-- 用戶表
CREATE TABLE Users (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Username VARCHAR(50) UNIQUE NOT NULL,
    Email VARCHAR(100) UNIQUE NOT NULL,
    PasswordHash VARCHAR(255) NOT NULL,
    DisplayName VARCHAR(100) NOT NULL,
    Avatar VARCHAR(255) DEFAULT '',
    IsActive BOOLEAN DEFAULT TRUE,
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (Username),
    INDEX idx_email (Email),
    INDEX idx_active (IsActive)
);

-- 初始測試資料
INSERT INTO Users (Username, Email, PasswordHash, DisplayName) VALUES
('admin', 'admin@example.com', '$2a$11$hashed_password', '管理員'),
('user1', 'user1@example.com', '$2a$11$hashed_password', '使用者1'),
('user2', 'user2@example.com', '$2a$11$hashed_password', '使用者2');
```

### 5.2 聊天服務資料庫
```sql
-- 好友關係表
CREATE TABLE Friends (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    RequesterId INT NOT NULL COMMENT '發送請求者ID',
    ReceiverId INT NOT NULL COMMENT '接收請求者ID',
    Status ENUM('pending', 'accepted', 'rejected', 'blocked') DEFAULT 'pending',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_friendship (RequesterId, ReceiverId),
    INDEX idx_requester_status (RequesterId, Status),
    INDEX idx_receiver_status (ReceiverId, Status)
);

-- 私人訊息表
CREATE TABLE Messages (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    SenderId INT NOT NULL COMMENT '發送者ID (0表示機器人)',
    ReceiverId INT NOT NULL COMMENT '接收者ID',
    Content TEXT NOT NULL COMMENT '訊息內容',
    MessageType ENUM('text', 'bot_reply') DEFAULT 'text',
    IsRead BOOLEAN DEFAULT FALSE COMMENT '是否已讀',
    ReadAt DATETIME NULL COMMENT '已讀時間',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_conversation (SenderId, ReceiverId, CreatedAt),
    INDEX idx_receiver_unread (ReceiverId, IsRead),
    INDEX idx_created_at (CreatedAt)
);
```

### 5.3 通知服務資料庫
```sql
-- 用戶連線狀態表
CREATE TABLE UserConnections (
    Id INT PRIMARY KEY AUTO_INCREMENT,
    UserId INT NOT NULL COMMENT '用戶ID',
    ConnectionId VARCHAR(255) NOT NULL COMMENT 'SignalR 連線ID',
    IsOnline BOOLEAN DEFAULT TRUE COMMENT '是否在線',
    LastSeen DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '最後活躍時間',
    CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_connection (ConnectionId),
    INDEX idx_user_online (UserId, IsOnline),
    INDEX idx_last_seen (LastSeen)
);
```

## 6. gRPC 服務契約

### 6.1 用戶服務契約
```protobuf
// ChatRoom.Shared.Contracts/user.proto
syntax = "proto3";
option csharp_namespace = "ChatRoom.Shared.Contracts";

service UserService {
  rpc GetUser(GetUserRequest) returns (UserResponse);
  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse);
  rpc ValidateUser(ValidateUserRequest) returns (ValidateUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  rpc SearchUsers(SearchUsersRequest) returns (SearchUsersResponse);
}

message GetUserRequest {
  int32 user_id = 1;
}

message GetUsersRequest {
  repeated int32 user_ids = 1;
}

message UserResponse {
  int32 id = 1;
  string username = 2;
  string display_name = 3;
  string avatar = 4;
  bool is_active = 5;
  string created_at = 6;
}

message GetUsersResponse {
  repeated UserResponse users = 1;
}

message ValidateUserRequest {
  int32 user_id = 1;
}

message ValidateUserResponse {
  bool is_valid = 1;
  string error_message = 2;
}
```

### 6.2 聊天服務契約
```protobuf
// ChatRoom.Shared.Contracts/chat.proto
syntax = "proto3";

service ChatService {
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
  rpc GetMessages(GetMessagesRequest) returns (GetMessagesResponse);
  rpc SendFriendRequest(SendFriendRequestRequest) returns (FriendRequestResponse);
  rpc AcceptFriendRequest(AcceptFriendRequestRequest) returns (FriendRequestResponse);
  rpc GetFriends(GetFriendsRequest) returns (GetFriendsResponse);
  rpc GetFriendRequests(GetFriendRequestsRequest) returns (GetFriendRequestsResponse);
}

message SendMessageRequest {
  int32 sender_id = 1;
  int32 receiver_id = 2;
  string content = 3;
  string message_type = 4;
}

message SendMessageResponse {
  bool success = 1;
  int32 message_id = 2;
  string error_message = 3;
}
```

## 7. ACL 防腐層

### 7.1 gRPC Client ACL
```csharp
// ChatRoom.Shared.Infrastructure/GrpcClients/IUserGrpcClient.cs
public interface IUserGrpcClient
{
    Task<UserDto?> GetUserAsync(int userId);
    Task<List<UserDto>> GetUsersAsync(IEnumerable<int> userIds);
    Task<bool> ValidateUserAsync(int userId);
    Task<List<UserDto>> SearchUsersAsync(string keyword);
}

// ChatRoom.Shared.Infrastructure/GrpcClients/UserGrpcClient.cs
public class UserGrpcClient : IUserGrpcClient
{
    private readonly UserService.UserServiceClient _grpcClient;
    private readonly ILogger<UserGrpcClient> _logger;

    public UserGrpcClient(UserService.UserServiceClient grpcClient, ILogger<UserGrpcClient> logger)
    {
        _grpcClient = grpcClient;
        _logger = logger;
    }

    public async Task<UserDto?> GetUserAsync(int userId)
    {
        try
        {
            var request = new GetUserRequest { UserId = userId };
            var response = await _grpcClient.GetUserAsync(request);
            
            // ACL: 外部模型轉內部模型
            return new UserDto
            {
                Id = response.Id,
                Username = response.Username,
                DisplayName = response.DisplayName,
                Avatar = response.Avatar,
                IsActive = response.IsActive
            };
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.NotFound)
        {
            _logger.LogWarning("User {UserId} not found", userId);
            return null;
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to get user {UserId} via gRPC", userId);
            throw new ExternalServiceException("User service unavailable", ex);
        }
    }

    public async Task<List<UserDto>> GetUsersAsync(IEnumerable<int> userIds)
    {
        try
        {
            var request = new GetUsersRequest();
            request.UserIds.AddRange(userIds);
            
            var response = await _grpcClient.GetUsersAsync(request);
            
            return response.Users.Select(u => new UserDto
            {
                Id = u.Id,
                Username = u.Username,
                DisplayName = u.DisplayName,
                Avatar = u.Avatar,
                IsActive = u.IsActive
            }).ToList();
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to get users via gRPC");
            throw new ExternalServiceException("User service unavailable", ex);
        }
    }

    public async Task<bool> ValidateUserAsync(int userId)
    {
        try
        {
            var request = new ValidateUserRequest { UserId = userId };
            var response = await _grpcClient.ValidateUserAsync(request);
            return response.IsValid;
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to validate user {UserId}", userId);
            return false;
        }
    }

    public async Task<List<UserDto>> SearchUsersAsync(string keyword)
    {
        try
        {
            var request = new SearchUsersRequest { Keyword = keyword };
            var response = await _grpcClient.SearchUsersAsync(request);
            
            return response.Users.Select(u => new UserDto
            {
                Id = u.Id,
                Username = u.Username,
                DisplayName = u.DisplayName,
                Avatar = u.Avatar,
                IsActive = u.IsActive
            }).ToList();
        }
        catch (RpcException ex)
        {
            _logger.LogError(ex, "Failed to search users with keyword {Keyword}", keyword);
            return new List<UserDto>();
        }
    }
}
```

### 7.2 HTTP Client ACL
```csharp
// ChatRoom.Shared.Infrastructure/HttpClients/INotificationHttpClient.cs
public interface INotificationHttpClient
{
    Task<bool> SendNotificationAsync(int userId, string message, string type);
    Task<bool> SendBulkNotificationAsync(IEnumerable<int> userIds, string message, string type);
}

// ChatRoom.Shared.Infrastructure/HttpClients/NotificationHttpClient.cs
public class NotificationHttpClient : INotificationHttpClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<NotificationHttpClient> _logger;

    public NotificationHttpClient(HttpClient httpClient, ILogger<NotificationHttpClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<bool> SendNotificationAsync(int userId, string message, string type)
    {
        try
        {
            var request = new
            {
                UserId = userId,
                Message = message,
                Type = type,
                Timestamp = DateTime.UtcNow
            };

            var json = JsonSerializer.Serialize(request, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _httpClient.PostAsync("/api/notifications", content);
            
            if (response.IsSuccessStatusCode)
            {
                _logger.LogDebug("Notification sent successfully to user {UserId}", userId);
                return true;
            }
            
            _logger.LogWarning("Failed to send notification to user {UserId}. Status: {StatusCode}", 
                userId, response.StatusCode);
            return false;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error when sending notification to user {UserId}", userId);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error when sending notification to user {UserId}", userId);
            return false;
        }
    }

    public async Task<bool> SendBulkNotificationAsync(IEnumerable<int> userIds, string message, string type)
    {
        try
        {
            var request = new
            {
                UserIds = userIds,
                Message = message,
                Type = type,
                Timestamp = DateTime.UtcNow
            };

            var json = JsonSerializer.Serialize(request, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await _httpClient.PostAsync("/api/notifications/bulk", content);
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending bulk notifications");
            return false;
        }
    }
}
```

## 8. JWT 認證架構

### 8.1 JWT Token 服務
```csharp
// ChatRoom.Shared.Infrastructure/Authentication/JwtTokenService.cs
public class JwtTokenService
{
    private readonly JwtSettings _settings;
    private readonly SymmetricSecurityKey _signingKey;

    public JwtTokenService(IOptions<JwtSettings> settings)
    {
        _settings = settings.Value;
        _signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.Secret));
    }

    public string GenerateToken(UserTokenInfo user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim("display_name", user.DisplayName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim(JwtRegisteredClaimNames.Iat, 
                DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
        };

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddHours(_settings.ExpiryHours),
            SigningCredentials = new SigningCredentials(_signingKey, SecurityAlgorithms.HmacSha256),
            Issuer = _settings.Issuer,
            Audience = _settings.Audience
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }

    public ClaimsPrincipal ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = _settings.Issuer,
            ValidAudience = _settings.Audience,
            IssuerSigningKey = _signingKey,
            ClockSkew = TimeSpan.Zero
        };

        var principal = tokenHandler.ValidateToken(token, validationParameters, out _);
        return principal;
    }
}

// JWT 設定
public class JwtSettings
{
    public const string SectionName = "JwtSettings";
    
    public string Secret { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public int ExpiryHours { get; set; } = 24;
}

public class UserTokenInfo
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
}
```

## 9. SignalR 即時通訊

### 9.1 Chat Hub 設計
```csharp
// ChatRoom.Notification.API/Hubs/ChatHub.cs
[Authorize]
public class ChatHub : Hub
{
    private readonly IMediator _mediator;
    private readonly ILogger<ChatHub> _logger;

    public ChatHub(IMediator mediator, ILogger<ChatHub> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    public async Task JoinUserGroup()
    {
        var userId = int.Parse(Context.UserIdentifier!);
        await Groups.AddToGroupAsync(Context.ConnectionId, $"user_{userId}");
        
        // 使用 MediatR 更新連線狀態
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, true);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} joined with connection {ConnectionId}", userId, Context.ConnectionId);
    }

    public async Task SendMessage(int receiverId, string message)
    {
        var senderId = int.Parse(Context.UserIdentifier!);
        
        try
        {
            // 使用 MediatR 發送訊息命令
            var command = new SendMessageCommand(senderId, receiverId, message);
            var result = await _mediator.Send(command);

            if (result.IsSuccess)
            {
                // 即時推送給接收者
                await Clients.Group($"user_{receiverId}")
                    .SendAsync("ReceiveMessage", new
                    {
                        MessageId = result.MessageId,
                        SenderId = senderId,
                        Content = message,
                        MessageType = "text",
                        Timestamp = DateTime.UtcNow
                    });

                // 機器人回覆也推送給發送者
                await Clients.Group($"user_{senderId}")
                    .SendAsync("ReceiveMessage", new
                    {
                        MessageId = result.MessageId + 1, // 機器人訊息 ID
                        SenderId = 0, // Bot ID
                        Content = $"Bot: {message}",
                        MessageType = "bot_reply",
                        Timestamp = DateTime.UtcNow
                    });

                // 回覆發送者確認
                await Clients.Caller.SendAsync("MessageSent", new { MessageId = result.MessageId });
            }
            else
            {
                await Clients.Caller.SendAsync("MessageError", result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending message from {SenderId} to {ReceiverId}", senderId, receiverId);
            await Clients.Caller.SendAsync("MessageError", "發送訊息失敗");
        }
    }

    public async Task MarkMessageAsRead(int messageId)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        
        try
        {
            // 使用 MediatR 標記已讀
            var command = new MarkMessageAsReadCommand(messageId, userId);
            await _mediator.Send(command);

            // 通知相關用戶訊息已讀
            await Clients.All.SendAsync("MessageRead", new { MessageId = messageId, ReadBy = userId });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error marking message {MessageId} as read by user {UserId}", messageId, userId);
        }
    }

    public override async Task OnConnectedAsync()
    {
        var userId = Context.UserIdentifier;
        _logger.LogInformation("User {UserId} connected with {ConnectionId}", userId, Context.ConnectionId);
        
        await JoinUserGroup();
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        var userId = int.Parse(Context.UserIdentifier!);
        
        // 使用 MediatR 更新連線狀態
        var command = new UpdateUserConnectionCommand(userId, Context.ConnectionId, false);
        await _mediator.Send(command);
        
        _logger.LogInformation("User {UserId} disconnected from {ConnectionId}", userId, Context.ConnectionId);
        await base.OnDisconnectedAsync(exception);
    }
}
```

## 10. Docker 部署

### 10.1 Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 資料庫
  mysql:
    image: mysql:8.0
    container_name: chatroom-mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: chatroom
      MYSQL_CHARACTER_SET_SERVER: utf8mb4
      MYSQL_COLLATION_SERVER: utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/migrations:/docker-entrypoint-initdb.d
    networks:
      - chatroom-network
    restart: unless-stopped

  # 用戶服務
  user-service:
    build:
      context: .
      dockerfile: src/Services/User/ChatRoom.User.API/Dockerfile
    container_name: chatroom-user-service
    ports:
      - "5001:80"
      - "5101:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_user;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - JwtSettings__Secret=your-super-secret-jwt-signing-key-that-is-long-enough-256-bits
      - JwtSettings__Issuer=ChatRoomApp
      - JwtSettings__Audience=ChatRoomUsers
      - JwtSettings__ExpiryHours=24
    depends_on:
      - mysql
    networks:
      - chatroom-network
    restart: unless-stopped

  # 聊天服務
  chat-service:
    build:
      context: .
      dockerfile: src/Services/Chat/ChatRoom.Chat.API/Dockerfile
    container_name: chatroom-chat-service
    ports:
      - "5002:80"
      - "5102:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_chat;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - Services__UserService__GrpcUrl=https://user-service:443
      - Services__NotificationService__HttpUrl=http://notification-service:80
    depends_on:
      - mysql
      - user-service
    networks:
      - chatroom-network
    restart: unless-stopped

  # 通知服務
  notification-service:
    build:
      context: .
      dockerfile: src/Services/Notification/ChatRoom.Notification.API/Dockerfile
    container_name: chatroom-notification-service
    ports:
      - "5003:80"
      - "5103:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=chatroom_notification;Uid=root;Pwd=rootpassword;Charset=utf8mb4;
      - Services__UserService__GrpcUrl=https://user-service:443
      - Services__ChatService__GrpcUrl=https://chat-service:443
      - JwtSettings__Secret=your-super-secret-jwt-signing-key-that-is-long-enough-256-bits
      - JwtSettings__Issuer=ChatRoomApp
      - JwtSettings__Audience=ChatRoomUsers
    depends_on:
      - mysql
      - user-service
    networks:
      - chatroom-network
    restart: unless-stopped

  # API 閘道
  api-gateway:
    build:
      context: .
      dockerfile: src/ApiGateway/ChatRoom.Gateway/Dockerfile
    container_name: chatroom-api-gateway
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - Services__UserService__Url=http://user-service:80
      - Services__ChatService__Url=http://chat-service:80
      - Services__NotificationService__Url=http://notification-service:80
    depends_on:
      - user-service
      - chat-service
      - notification-service
    networks:
      - chatroom-network
    restart: unless-stopped

volumes:
  mysql_data:
    driver: local

networks:
  chatroom-network:
    driver: bridge
```

### 10.2 資料庫初始化腳本
```sql
-- database/migrations/01_create_databases.sql
CREATE DATABASE IF NOT EXISTS chatroom_user CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS chatroom_chat CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE DATABASE IF NOT EXISTS chatroom_notification CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 建立用戶
CREATE USER IF NOT EXISTS 'chatroom_user'@'%' IDENTIFIED BY 'chatroom_password';
GRANT ALL PRIVILEGES ON chatroom_user.* TO 'chatroom_user'@'%';
GRANT ALL PRIVILEGES ON chatroom_chat.* TO 'chatroom_user'@'%';
GRANT ALL PRIVILEGES ON chatroom_notification.* TO 'chatroom_user'@'%';
FLUSH PRIVILEGES;
```

## 11. 開發規範

### 11.1 MediatR 使用規範

**❌ 錯誤做法 - 不要二次封裝 MediatR:**
```csharp
// 不要這樣做
public interface ICommand<out TResponse> : IRequest<TResponse> { }
public interface ICommandHandler<in TCommand, TResponse> : IRequestHandler<TCommand, TResponse>
    where TCommand : ICommand<TResponse> { }

public class SendMessageCommand : ICommand<SendMessageResult> // 不要多此一舉
```

**✅ 正確做法 - 直接使用 MediatR:**
```csharp
// 直接使用 MediatR 介面
public record SendMessageCommand(int SenderId, int ReceiverId, string Content) : IRequest<SendMessageResult>;

public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    // 實作邏輯...
}
```

### 11.2 命名規範
- **專案命名**: `ChatRoom.{Service}.{Layer}`
- **檔案命名**: PascalCase
- **介面命名**: 以 `I` 開頭
- **常數命名**: UPPER_SNAKE_CASE
- **方法命名**: PascalCase，Async 方法以 `Async` 結尾

### 11.3 錯誤處理
```csharp
// 全域異常處理中介軟體
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        
        var response = exception switch
        {
            ExternalServiceException => new { error = "External service error", message = exception.Message, statusCode = 503 },
            ArgumentException => new { error = "Invalid request", message = exception.Message, statusCode = 400 },
            UnauthorizedAccessException => new { error = "Unauthorized", message = "Access denied", statusCode = 401 },
            _ => new { error = "Internal server error", message = "An error occurred", statusCode = 500 }
        };

        context.Response.StatusCode = response.statusCode;
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 11.4 日誌規範
```csharp
// 結構化日誌範例
public class SendMessageCommandHandler : IRequestHandler<SendMessageCommand, SendMessageResult>
{
    private readonly ILogger<SendMessageCommandHandler> _logger;

    public async Task<SendMessageResult> Handle(SendMessageCommand request, CancellationToken cancellationToken)
    {
        using var scope = _logger.BeginScope(new Dictionary<string, object>
        {
            ["SenderId"] = request.SenderId,
            ["ReceiverId"] = request.ReceiverId
        });

        _logger.LogInformation("Processing send message command");

        try
        {
            // 業務邏輯...
            _logger.LogInformation("Message sent successfully with ID {MessageId}", messageId);
            return SendMessageResult.Success(messageId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send message");
            throw;
        }
    }
}
```

### 11.5 測試規範
```csharp
// 單元測試範例
public class SendMessageCommandHandlerTests
{
    private readonly Mock<IMessageRepository> _mockMessageRepository;
    private readonly Mock<IUserGrpcClient> _mockUserGrpcClient;
    private readonly SendMessageCommandHandler _handler;

    public SendMessageCommandHandlerTests()
    {
        _mockMessageRepository = new Mock<IMessageRepository>();
        _mockUserGrpcClient = new Mock<IUserGrpcClient>();
        _handler = new SendMessageCommandHandler(
            _mockMessageRepository.Object,
            _mockUserGrpcClient.Object,
            Mock.Of<INotificationHttpClient>(),
            Mock.Of<ILogger<SendMessageCommandHandler>>());
    }

    [Fact]
    public async Task Handle_ValidRequest_ReturnsSuccess()
    {
        // Arrange
        var command = new SendMessageCommand(1, 2, "Hello");
        _mockUserGrpcClient.Setup(x => x.GetUserAsync(It.IsAny<int>()))
            .ReturnsAsync(new UserDto { Id = 1, IsActive = true });
        _mockMessageRepository.Setup(x => x.CreateAsync(It.IsAny<Message>()))
            .ReturnsAsync(123);

        // Act
        var result = await _handler.Handle(command, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(123, result.MessageId);
    }
}
```

---

**文件版本**: 1.0  
**最後更新**: 2025-06-08  
**維護者**: 開發團隊

**重要提醒**: 
- 直接使用 MediatR 的 `IRequest` 和 `IRequestHandler` 介面
- 不要建立額外的抽象層如 `ICommand` 或 `IQuery`
- 保持架構簡潔，專注於業務邏輯實現
